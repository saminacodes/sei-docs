---
title: 'Pointer Precompile'
description: "Learn how to use Sei's Pointer precompile to create EVM-compatible interfaces for native Cosmos SDK tokens and CosmWasm contracts, enabling seamless interoperability between EVM and Cosmos ecosystems."
keywords: ['pointer precompile', 'cosmos sdk', 'cosmwasm', 'cw20', 'cw721', 'native tokens', 'interoperability', 'sei development']
---

import { Callout } from 'nextra/components';
import { Tabs } from 'nextra/components';

# Pointer Precompile

**Address:** `0x000000000000000000000000000000000000100B`

The Sei Pointer precompile enables EVM applications to create EVM-compatible interfaces (pointers) for native Cosmos SDK tokens and CosmWasm contracts. This allows developers to interact with Cosmos-native assets using familiar EVM patterns and tools, bridging the gap between the two ecosystems.

<Callout type="info">**What is a pointer?** A pointer is an EVM-compatible smart contract interface that represents a Cosmos SDK native token or CosmWasm contract. It allows EVM applications to interact with Cosmos-native assets as if they were standard ERC-20 or ERC-721 tokens.</Callout>

## How Does the Pointer Precompile Work?

The Pointer precompile at address `0x000000000000000000000000000000000000100B` provides functions to create EVM pointers for different types of Cosmos assets:

- **Native Asset Integration:** Create ERC-20 compatible interfaces for Cosmos SDK native tokens
- **CosmWasm Compatibility:** Bridge CW20 and CW721 contracts to EVM standards
- **Seamless Interoperability:** Use existing EVM tooling with Cosmos-native assets
- **Automatic Standards:** Generated pointers follow ERC-20/ERC-721 standards automatically

## Use Cases

- **Cross-Ecosystem DeFi:** Build EVM-based DeFi protocols that can utilize Cosmos-native tokens
- **Unified Interfaces:** Create applications that seamlessly work with both EVM and Cosmos assets
- **Migration Tools:** Help projects transition between Cosmos and EVM ecosystems
- **Asset Bridging:** Enable existing EVM tools and wallets to interact with Cosmos assets
- **Multi-Standard Support:** Support both fungible (ERC-20) and non-fungible (ERC-721) token standards

## What You'll Learn in This Guide

By the end of this guide, you'll be able to:

- **Create Native Pointers** - Generate EVM interfaces for Cosmos SDK native tokens
- **Bridge CW20 Tokens** - Make CosmWasm CW20 tokens accessible via ERC-20 interface
- **Handle CW721 NFTs** - Create ERC-721 compatible interfaces for CosmWasm NFTs
- **Manage Pointer Lifecycles** - Understand pointer creation, usage, and best practices
- **Build Interoperable dApps** - Develop applications that work across both ecosystems

## Functions

The Pointer precompile exposes the following functions:

### Transaction Functions

```solidity
/// Adds a native pointer for the contract.
/// @param token The native token denomination to add (e.g., "usei", "uatom").
/// @return ret An Ethereum address of the created pointer contract.
function addNativePointer(
    string memory token
) external returns (address ret);

/// Adds a CW20 pointer for the contract.
/// @param cwAddr The CW20 contract address to add.
/// @return ret An Ethereum address of the created pointer contract.
function addCW20Pointer(
    string memory cwAddr
) external returns (address ret);

/// Adds a CW721 pointer for the contract.
/// @param cwAddr The CW721 contract address to add.
/// @return ret An Ethereum address of the created pointer contract.
function addCW721Pointer(
    string memory cwAddr
) external returns (address ret);
```

## Using the Precompile

### Setup

#### Prerequisites

Before getting started, ensure you have:

- **Node.js** (v16 or higher)
- **npm** or **yarn** package manager
- **EVM-compatible wallet** with SEI tokens for gas fees
- **Knowledge of target assets** - native token denoms or CosmWasm contract addresses

#### Install Dependencies

Install the required packages for interacting with Sei precompiles:

```bash copy
# Install ethers.js for smart contract interactions
npm install ethers

# Install Sei EVM bindings for precompile addresses and ABIs
npm install @sei-js/precompiles@2.1.2
```

#### Import Precompile Components

<Tabs items={['JavaScript','Solidity']}>
<Tabs.Tab>
```typescript copy
// Import ethers for contract interactions
import { ethers } from 'ethers';

// Pointer precompile constants
const POINTER_PRECOMPILE_ADDRESS = '0x000000000000000000000000000000000000100B';
const POINTER_PRECOMPILE_ABI = [
"function addNativePointer(string) external returns (address)",
"function addCW20Pointer(string) external returns (address)",
"function addCW721Pointer(string) external returns (address)"
];

````
</Tabs.Tab>
<Tabs.Tab>
```solidity copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPointerPrecompile {
    function addNativePointer(
        string memory token
    ) external returns (address ret);

    function addCW20Pointer(
        string memory cwAddr
    ) external returns (address ret);

    function addCW721Pointer(
        string memory cwAddr
    ) external returns (address ret);
}
````

</Tabs.Tab>
</Tabs>

<Callout type="info">**Precompile Address:** The Pointer precompile is deployed at `0x000000000000000000000000000000000000100B`</Callout>

### Contract Initialization

<Tabs items={['JavaScript','Solidity']}>
<Tabs.Tab>
Set up your provider, signer, and contract instance:

```typescript copy
// Using EVM-compatible wallet as the signer and provider
const provider = new ethers.BrowserProvider(window.ethereum);
await provider.send('eth_requestAccounts', []);
const signer = await provider.getSigner();

// Create a contract instance for the Pointer precompile
const pointer = new ethers.Contract(POINTER_PRECOMPILE_ADDRESS, POINTER_PRECOMPILE_ABI, signer);
```

</Tabs.Tab>
<Tabs.Tab>
```solidity copy
// Initialize the contract instance in your Solidity code
contract PointerManager {
    IPointerPrecompile constant POINTER = IPointerPrecompile(0x000000000000000000000000000000000000100B);
}
```
</Tabs.Tab>
</Tabs>

#### Understanding Pointer Parameters

Each pointer type requires specific parameters:

<div className="overflow-x-auto max-w-full">
  <table className="w-full divide-y divide-neutral-200 dark:divide-neutral-800">
    <thead>
      <tr>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Pointer Type</th>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Parameter</th>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Example</th>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Result</th>
      </tr>
    </thead>
    <tbody className="divide-y divide-neutral-200 dark:divide-neutral-800">
      <tr>
        <td className="px-4 py-3 text-sm text-neutral-900 dark:text-neutral-100 whitespace-nowrap font-medium">**Native**</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Token denomination</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400 font-mono">usei</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">ERC-20 compatible contract</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-neutral-900 dark:text-neutral-100 whitespace-nowrap font-medium">**CW20**</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Contract address</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400 font-mono">sei1abc...</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">ERC-20 compatible contract</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-neutral-900 dark:text-neutral-100 whitespace-nowrap font-medium">**CW721**</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Contract address</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400 font-mono">sei1def...</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">ERC-721 compatible contract</td>
      </tr>
    </tbody>
  </table>
</div>

### Pointer Types Comparison

**Native Pointers:**

- Bridge Cosmos SDK native tokens to ERC-20
- Best for chain-native assets like SEI, ATOM
- Automatic decimals handling
- Direct bank module integration

**CW20 Pointers:**

- Bridge CosmWasm CW20 tokens to ERC-20
- Compatible with existing CW20 contracts
- Maintains token metadata and functionality
- Ideal for custom fungible tokens

**CW721 Pointers:**

- Bridge CosmWasm CW721 NFTs to ERC-721
- Full NFT metadata support
- Compatible with OpenSea and EVM NFT tools
- Enables cross-ecosystem NFT trading

## Step-by-Step Guide: Using the Pointer Precompile

### Creating a Native Token Pointer

<Tabs items={['JavaScript','Solidity']}>
<Tabs.Tab>

```typescript copy
// Create a pointer for native SEI tokens
async function createNativePointer() {
  const tokenDenom = 'usei'; // Native SEI denomination

  try {
    console.log('Creating native pointer for:', tokenDenom);

    // Estimate gas first
    const gasEstimate = await pointer.addNativePointer.estimateGas(tokenDenom);

    // Create the pointer
    const tx = await pointer.addNativePointer(tokenDenom, {
      gasLimit: (gasEstimate * 12n) / 10n // Add 20% buffer
    });

    const receipt = await tx.wait();
    console.log('Transaction successful:', receipt.transactionHash);

    // Extract the pointer address from events/logs
    // The returned address will be in the transaction logs
    console.log('Native pointer created successfully');

    // The actual pointer address would be returned by the function
    // You can call the function as a view to get the address without creating
    return receipt;
  } catch (error) {
    console.error('Failed to create native pointer:', error.message);

    if (error.message.includes('pointer already exists')) {
      console.log('Pointer for this token already exists');
    } else if (error.message.includes('invalid token denom')) {
      console.error('Invalid token denomination');
    }

    throw error;
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```solidity copy
contract NativePointerManager {
    IPointerPrecompile constant POINTER = IPointerPrecompile(0x000000000000000000000000000000000000100B);

    // Store created pointers
    mapping(string => address) public nativePointers;

    event NativePointerCreated(string indexed tokenDenom, address pointerAddress);

    function createNativePointer(string memory tokenDenom) external returns (address pointerAddr) {
        // Check if pointer already exists
        require(nativePointers[tokenDenom] == address(0), "Pointer already exists");

        // Create the native pointer
        pointerAddr = POINTER.addNativePointer(tokenDenom);

        // Store the pointer address
        nativePointers[tokenDenom] = pointerAddr;

        emit NativePointerCreated(tokenDenom, pointerAddr);

        return pointerAddr;
    }

    function getNativePointer(string memory tokenDenom) external view returns (address) {
        return nativePointers[tokenDenom];
    }
}
```

</Tabs.Tab>
</Tabs>

### Creating a CW20 Token Pointer

<Tabs items={['JavaScript','Solidity']}>
<Tabs.Tab>

```typescript copy
// Create a pointer for a CW20 token
async function createCW20Pointer() {
  // Example CW20 contract address (use actual contract address)
  const cw20Address = 'sei1hrpna9v7vs3stzyd4z3xf00676kf78zpe2u5ksvljswn2vnjp3yqtxqz3t';

  try {
    console.log('Creating CW20 pointer for:', cw20Address);

    // Validate address format
    if (!cw20Address.startsWith('sei1') || cw20Address.length < 40) {
      throw new Error('Invalid CW20 contract address format');
    }

    // Create the pointer
    const tx = await pointer.addCW20Pointer(cw20Address);
    const receipt = await tx.wait();

    console.log('CW20 pointer created:', receipt.transactionHash);

    // The pointer address would be available in the transaction logs
    // or returned by the function call
    return receipt;
  } catch (error) {
    console.error('Failed to create CW20 pointer:', error.message);

    if (error.message.includes('contract does not exist')) {
      console.error('CW20 contract not found at the provided address');
    } else if (error.message.includes('not a CW20 contract')) {
      console.error('Contract exists but is not a valid CW20 contract');
    }

    throw error;
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```solidity copy
contract CW20PointerManager {
    IPointerPrecompile constant POINTER = IPointerPrecompile(0x000000000000000000000000000000000000100B);

    // Store created CW20 pointers
    mapping(string => address) public cw20Pointers;
    string[] public cw20Contracts;

    event CW20PointerCreated(string indexed contractAddr, address pointerAddress);

    function createCW20Pointer(string memory contractAddr) external returns (address pointerAddr) {
        // Validate input
        require(bytes(contractAddr).length > 0, "Contract address cannot be empty");
        require(cw20Pointers[contractAddr] == address(0), "Pointer already exists");

        // Create the CW20 pointer
        pointerAddr = POINTER.addCW20Pointer(contractAddr);

        // Store the pointer address
        cw20Pointers[contractAddr] = pointerAddr;
        cw20Contracts.push(contractAddr);

        emit CW20PointerCreated(contractAddr, pointerAddr);

        return pointerAddr;
    }

    function getCW20Pointer(string memory contractAddr) external view returns (address) {
        return cw20Pointers[contractAddr];
    }

    function getAllCW20Contracts() external view returns (string[] memory) {
        return cw20Contracts;
    }

    function getCW20ContractCount() external view returns (uint256) {
        return cw20Contracts.length;
    }
}
```

</Tabs.Tab>
</Tabs>

### Creating a CW721 NFT Pointer

<Tabs items={['JavaScript','Solidity']}>
<Tabs.Tab>

```typescript copy
// Create a pointer for a CW721 NFT contract
async function createCW721Pointer() {
  // Example CW721 contract address (use actual contract address)
  const cw721Address = 'sei1nft789abcdef123456789abcdef123456789abcdef123456789abcdef12';

  try {
    console.log('Creating CW721 pointer for:', cw721Address);

    // Validate address format
    if (!cw721Address.startsWith('sei1') || cw721Address.length < 40) {
      throw new Error('Invalid CW721 contract address format');
    }

    // Estimate gas for NFT pointer creation (may require more gas)
    const gasEstimate = await pointer.addCW721Pointer.estimateGas(cw721Address);

    // Create the pointer with higher gas limit for NFT operations
    const tx = await pointer.addCW721Pointer(cw721Address, {
      gasLimit: (gasEstimate * 15n) / 10n // Add 50% buffer for NFT operations
    });

    const receipt = await tx.wait();
    console.log('CW721 pointer created:', receipt.transactionHash);

    // The ERC-721 compatible contract is now available at the returned address
    console.log('NFT collection is now EVM-compatible');

    return receipt;
  } catch (error) {
    console.error('Failed to create CW721 pointer:', error.message);

    if (error.message.includes('contract does not exist')) {
      console.error('CW721 contract not found at the provided address');
    } else if (error.message.includes('not a CW721 contract')) {
      console.error('Contract exists but is not a valid CW721 contract');
    }

    throw error;
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```solidity copy
contract CW721PointerManager {
    IPointerPrecompile constant POINTER = IPointerPrecompile(0x000000000000000000000000000000000000100B);

    // Store created CW721 pointers
    mapping(string => address) public cw721Pointers;
    string[] public cw721Contracts;

    struct NFTCollection {
        string contractAddr;
        address pointerAddr;
        uint256 createdAt;
        address creator;
    }

    mapping(string => NFTCollection) public collections;

    event CW721PointerCreated(
        string indexed contractAddr,
        address indexed pointerAddress,
        address indexed creator
    );

    function createCW721Pointer(string memory contractAddr) external returns (address pointerAddr) {
        // Validate input
        require(bytes(contractAddr).length > 0, "Contract address cannot be empty");
        require(cw721Pointers[contractAddr] == address(0), "Pointer already exists");

        // Create the CW721 pointer
        pointerAddr = POINTER.addCW721Pointer(contractAddr);

        // Store the pointer address and collection info
        cw721Pointers[contractAddr] = pointerAddr;
        cw721Contracts.push(contractAddr);

        collections[contractAddr] = NFTCollection({
            contractAddr: contractAddr,
            pointerAddr: pointerAddr,
            createdAt: block.timestamp,
            creator: msg.sender
        });

        emit CW721PointerCreated(contractAddr, pointerAddr, msg.sender);

        return pointerAddr;
    }

    function getCW721Pointer(string memory contractAddr) external view returns (address) {
        return cw721Pointers[contractAddr];
    }

    function getCollectionInfo(string memory contractAddr) external view returns (NFTCollection memory) {
        return collections[contractAddr];
    }

    function getAllCW721Contracts() external view returns (string[] memory) {
        return cw721Contracts;
    }

    function getCW721ContractCount() external view returns (uint256) {
        return cw721Contracts.length;
    }
}
```

</Tabs.Tab>
</Tabs>

### Multi-Asset Pointer Manager

<Tabs items={['JavaScript','Solidity']}>
<Tabs.Tab>

```typescript copy
// Comprehensive pointer management system
class PointerManager {
  constructor(signer) {
    this.pointer = new ethers.Contract(POINTER_PRECOMPILE_ADDRESS, POINTER_PRECOMPILE_ABI, signer);
    this.pointers = {
      native: new Map(),
      cw20: new Map(),
      cw721: new Map()
    };
  }

  async createNativePointers(tokenDenoms) {
    const results = [];

    for (const denom of tokenDenoms) {
      try {
        console.log(`Creating native pointer for: ${denom}`);

        const tx = await this.pointer.addNativePointer(denom);
        const receipt = await tx.wait();

        // In a real implementation, you'd extract the address from logs
        const pointerAddress = '0x...'; // Extract from transaction logs

        this.pointers.native.set(denom, pointerAddress);

        results.push({
          type: 'native',
          asset: denom,
          pointerAddress,
          txHash: receipt.transactionHash,
          success: true
        });

        // Add delay between transactions
        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Failed to create pointer for ${denom}:`, error);
        results.push({
          type: 'native',
          asset: denom,
          error: error.message,
          success: false
        });
      }
    }

    return results;
  }

  async createCW20Pointers(contractAddresses) {
    const results = [];

    for (const contractAddr of contractAddresses) {
      try {
        console.log(`Creating CW20 pointer for: ${contractAddr}`);

        // Validate address format
        if (!contractAddr.startsWith('sei1')) {
          throw new Error('Invalid contract address format');
        }

        const tx = await this.pointer.addCW20Pointer(contractAddr);
        const receipt = await tx.wait();

        // Extract pointer address from logs
        const pointerAddress = '0x...'; // Extract from transaction logs

        this.pointers.cw20.set(contractAddr, pointerAddress);

        results.push({
          type: 'cw20',
          asset: contractAddr,
          pointerAddress,
          txHash: receipt.transactionHash,
          success: true
        });

        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Failed to create CW20 pointer for ${contractAddr}:`, error);
        results.push({
          type: 'cw20',
          asset: contractAddr,
          error: error.message,
          success: false
        });
      }
    }

    return results;
  }

  async createCW721Pointers(contractAddresses) {
    const results = [];

    for (const contractAddr of contractAddresses) {
      try {
        console.log(`Creating CW721 pointer for: ${contractAddr}`);

        const tx = await this.pointer.addCW721Pointer(contractAddr);
        const receipt = await tx.wait();

        const pointerAddress = '0x...'; // Extract from transaction logs

        this.pointers.cw721.set(contractAddr, pointerAddress);

        results.push({
          type: 'cw721',
          asset: contractAddr,
          pointerAddress,
          txHash: receipt.transactionHash,
          success: true
        });

        await new Promise((resolve) => setTimeout(resolve, 1500)); // NFTs might need more time
      } catch (error) {
        console.error(`Failed to create CW721 pointer for ${contractAddr}:`, error);
        results.push({
          type: 'cw721',
          asset: contractAddr,
          error: error.message,
          success: false
        });
      }
    }

    return results;
  }

  // Batch create all types of pointers
  async batchCreatePointers(config) {
    const results = {
      native: [],
      cw20: [],
      cw721: []
    };

    if (config.native?.length > 0) {
      results.native = await this.createNativePointers(config.native);
    }

    if (config.cw20?.length > 0) {
      results.cw20 = await this.createCW20Pointers(config.cw20);
    }

    if (config.cw721?.length > 0) {
      results.cw721 = await this.createCW721Pointers(config.cw721);
    }

    return results;
  }

  getPointerAddress(type, asset) {
    return this.pointers[type]?.get(asset);
  }

  getAllPointers() {
    return {
      native: Object.fromEntries(this.pointers.native),
      cw20: Object.fromEntries(this.pointers.cw20),
      cw721: Object.fromEntries(this.pointers.cw721)
    };
  }
}

// Usage example
async function comprehensivePointerExample() {
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const manager = new PointerManager(signer);

  // Configuration for different asset types
  const pointerConfig = {
    native: ['usei', 'uatom'], // Native token denominations
    cw20: [
      'sei1hrpna9v7vs3stzyd4z3xf00676kf78zpe2u5ksvljswn2vnjp3yqtxqz3t',
      'sei1abc123def456789...' // Add actual CW20 addresses
    ],
    cw721: [
      'sei1nft789abcdef123456789abcdef123456789abcdef123456789abcdef12',
      'sei1xyz987uvw654321...' // Add actual CW721 addresses
    ]
  };

  try {
    console.log('Creating pointers for all asset types...');
    const results = await manager.batchCreatePointers(pointerConfig);

    console.log('Pointer creation results:');
    console.log('Native tokens:', results.native);
    console.log('CW20 tokens:', results.cw20);
    console.log('CW721 NFTs:', results.cw721);

    // Get all created pointers
    const allPointers = manager.getAllPointers();
    console.log('All created pointers:', allPointers);
  } catch (error) {
    console.error('Batch pointer creation failed:', error);
  }
}
```

</Tabs.Tab>
<Tabs.Tab>

```solidity copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ComprehensivePointerManager {
    IPointerPrecompile constant POINTER = IPointerPrecompile(0x000000000000000000000000000000000000100B);

    // Pointer registries
    mapping(string => address) public nativePointers;
    mapping(string => address) public cw20Pointers;
    mapping(string => address) public cw721Pointers;

    // Asset lists
    string[] public nativeTokens;
    string[] public cw20Contracts;
    string[] public cw721Contracts;

    // Metadata
    struct PointerInfo {
        address pointerAddress;
        uint256 createdAt;
        address creator;
        bool active;
    }

    mapping(bytes32 => PointerInfo) public pointerRegistry;

    // Events
    event PointerCreated(
        string indexed assetType,
        string indexed asset,
        address indexed pointerAddress,
        address creator
    );

    event BatchPointerCreation(
        address indexed creator,
        uint256 nativeCount,
        uint256 cw20Count,
        uint256 cw721Count
    );

    // Access control
    address public owner;
    mapping(address => bool) public authorized;

    modifier onlyAuthorized() {
        require(authorized[msg.sender] || msg.sender == owner, "Not authorized");
        _;
    }

    constructor() {
        owner = msg.sender;
        authorized[msg.sender] = true;
    }

    function createNativePointer(string memory tokenDenom) external returns (address pointerAddr) {
        require(bytes(tokenDenom).length > 0, "Token denom cannot be empty");
        require(nativePointers[tokenDenom] == address(0), "Pointer already exists");

        pointerAddr = POINTER.addNativePointer(tokenDenom);

        nativePointers[tokenDenom] = pointerAddr;
        nativeTokens.push(tokenDenom);

        bytes32 key = keccak256(abi.encodePacked("native", tokenDenom));
        pointerRegistry[key] = PointerInfo({
            pointerAddress: pointerAddr,
            createdAt: block.timestamp,
            creator: msg.sender,
            active: true
        });

        emit PointerCreated("native", tokenDenom, pointerAddr, msg.sender);

        return pointerAddr;
    }

    function createCW20Pointer(string memory contractAddr) external returns (address pointerAddr) {
        require(bytes(contractAddr).length > 0, "Contract address cannot be empty");
        require(cw20Pointers[contractAddr] == address(0), "Pointer already exists");

        pointerAddr = POINTER.addCW20Pointer(contractAddr);

        cw20Pointers[contractAddr] = pointerAddr;
        cw20Contracts.push(contractAddr);

        bytes32 key = keccak256(abi.encodePacked("cw20", contractAddr));
        pointerRegistry[key] = PointerInfo({
            pointerAddress: pointerAddr,
            createdAt: block.timestamp,
            creator: msg.sender,
            active: true
        });

        emit PointerCreated("cw20", contractAddr, pointerAddr, msg.sender);

        return pointerAddr;
    }

    function createCW721Pointer(string memory contractAddr) external returns (address pointerAddr) {
        require(bytes(contractAddr).length > 0, "Contract address cannot be empty");
        require(cw721Pointers[contractAddr] == address(0), "Pointer already exists");

        pointerAddr = POINTER.addCW721Pointer(contractAddr);

        cw721Pointers[contractAddr] = pointerAddr;
        cw721Contracts.push(contractAddr);

        bytes32 key = keccak256(abi.encodePacked("cw721", contractAddr));
        pointerRegistry[key] = PointerInfo({
            pointerAddress: pointerAddr,
            createdAt: block.timestamp,
            creator: msg.sender,
            active: true
        });

        emit PointerCreated("cw721", contractAddr, pointerAddr, msg.sender);

        return pointerAddr;
    }

    function batchCreateNativePointers(
        string[] memory tokenDenoms
    ) external onlyAuthorized returns (address[] memory pointerAddresses) {
        require(tokenDenoms.length > 0, "No tokens provided");
        require(tokenDenoms.length <= 50, "Too many tokens"); // Gas limit protection

        pointerAddresses = new address[](tokenDenoms.length);

        for (uint256 i = 0; i < tokenDenoms.length; i++) {
            if (nativePointers[tokenDenoms[i]] == address(0)) {
                pointerAddresses[i] = createNativePointer(tokenDenoms[i]);
            } else {
                pointerAddresses[i] = nativePointers[tokenDenoms[i]];
            }
        }

        return pointerAddresses;
    }

    function batchCreateCW20Pointers(
        string[] memory contractAddrs
    ) external onlyAuthorized returns (address[] memory pointerAddresses) {
        require(contractAddrs.length > 0, "No contracts provided");
        require(contractAddrs.length <= 25, "Too many contracts");

        pointerAddresses = new address[](contractAddrs.length);

        for (uint256 i = 0; i < contractAddrs.length; i++) {
            if (cw20Pointers[contractAddrs[i]] == address(0)) {
                pointerAddresses[i] = createCW20Pointer(contractAddrs[i]);
            } else {
                pointerAddresses[i] = cw20Pointers[contractAddrs[i]];
            }
        }

        return pointerAddresses;
    }

    function batchCreateCW721Pointers(
        string[] memory contractAddrs
    ) external onlyAuthorized returns (address[] memory pointerAddresses) {
        require(contractAddrs.length > 0, "No contracts provided");
        require(contractAddrs.length <= 10, "Too many NFT contracts"); // Lower limit for NFTs

        pointerAddresses = new address[](contractAddrs.length);

        for (uint256 i = 0; i < contractAddrs.length; i++) {
            if (cw721Pointers[contractAddrs[i]] == address(0)) {
                pointerAddresses[i] = createCW721Pointer(contractAddrs[i]);
            } else {
                pointerAddresses[i] = cw721Pointers[contractAddrs[i]];
            }
        }

        return pointerAddresses;
    }

    // Comprehensive batch creation
    function batchCreateAllPointers(
        string[] memory nativeTokenDenoms,
        string[] memory cw20ContractAddrs,
        string[] memory cw721ContractAddrs
    ) external onlyAuthorized {
        uint256 nativeCount = 0;
        uint256 cw20Count = 0;
        uint256 cw721Count = 0;

        if (nativeTokenDenoms.length > 0) {
            batchCreateNativePointers(nativeTokenDenoms);
            nativeCount = nativeTokenDenoms.length;
        }

        if (cw20ContractAddrs.length > 0) {
            batchCreateCW20Pointers(cw20ContractAddrs);
            cw20Count = cw20ContractAddrs.length;
        }

        if (cw721ContractAddrs.length > 0) {
            batchCreateCW721Pointers(cw721ContractAddrs);
            cw721Count = cw721ContractAddrs.length;
        }

        emit BatchPointerCreation(msg.sender, nativeCount, cw20Count, cw721Count);
    }

    // View functions
    function getPointerInfo(string memory assetType, string memory asset)
        external view returns (PointerInfo memory) {
        bytes32 key = keccak256(abi.encodePacked(assetType, asset));
        return pointerRegistry[key];
    }

    function getAllNativeTokens() external view returns (string[] memory) {
        return nativeTokens;
    }

    function getAllCW20Contracts() external view returns (string[] memory) {
        return cw20Contracts;
    }

    function getAllCW721Contracts() external view returns (string[] memory) {
        return cw721Contracts;
    }

    function getTotalPointerCount() external view returns (uint256, uint256, uint256) {
        return (nativeTokens.length, cw20Contracts.length, cw721Contracts.length);
    }

    // Admin functions
    function setAuthorized(address user, bool _authorized) external {
        require(msg.sender == owner, "Only owner");
        authorized[user] = _authorized;
    }

    function transferOwnership(address newOwner) external {
        require(msg.sender == owner, "Only owner");
        require(newOwner != address(0), "Invalid new owner");
        owner = newOwner;
    }
}
```

</Tabs.Tab>
</Tabs>

## Security Considerations & Best Practices

### Pointer Creation Validation

- **Asset Verification:** Always verify that the target asset (native token or CosmWasm contract) exists before creating a pointer
- **Duplicate Prevention:** Check if a pointer already exists to avoid unnecessary gas costs
- **Address Format:** Validate CosmWasm contract address formats before pointer creation

### Access Control

```solidity copy
// Implement proper access control for pointer creation
modifier onlyAuthorized() {
    require(authorized[msg.sender] || msg.sender == owner, "Not authorized");
    _;
}

// Consider rate limiting for pointer creation
mapping(address => uint256) public lastPointerCreation;
uint256 public constant CREATION_COOLDOWN = 60; // 1 minute

modifier rateLimited() {
    require(
        block.timestamp >= lastPointerCreation[msg.sender] + CREATION_COOLDOWN,
        "Rate limit exceeded"
    );
    lastPointerCreation[msg.sender] = block.timestamp;
    _;
}
```

### Gas Management

- **Batch Operations:** Use batch functions when creating multiple pointers to save gas
- **Gas Estimation:** Always estimate gas before pointer creation, especially for CW721
- **Limits:** Implement reasonable limits on batch operations to prevent gas limit issues

## Working with Created Pointers

### Using Native Token Pointers

Once you create a native token pointer, you can interact with it like any ERC-20 token:

```typescript copy
// After creating a native pointer for 'usei'
const ERC20_ABI = ['function balanceOf(address) view returns (uint256)', 'function transfer(address, uint256) returns (bool)', 'function approve(address, uint256) returns (bool)'];

const seiPointer = new ethers.Contract(pointerAddress, ERC20_ABI, signer);

// Check balance
const balance = await seiPointer.balanceOf(userAddress);
console.log('SEI balance:', ethers.formatUnits(balance, 6)); // SEI has 6 decimals

// Transfer tokens
const transferTx = await seiPointer.transfer(recipientAddress, amount);
```

### Using CW20 Pointers

CW20 pointers function as standard ERC-20 tokens:

```typescript copy
// Interact with CW20 pointer as ERC-20
const cw20Pointer = new ethers.Contract(pointerAddress, ERC20_ABI, signer);

// All standard ERC-20 functions are available
const totalSupply = await cw20Pointer.totalSupply();
const decimals = await cw20Pointer.decimals();
const symbol = await cw20Pointer.symbol();
```

### Using CW721 Pointers

CW721 pointers work as standard ERC-721 tokens:

```typescript copy
const ERC721_ABI = ['function balanceOf(address) view returns (uint256)', 'function ownerOf(uint256) view returns (address)', 'function transferFrom(address, address, uint256)', 'function approve(address, uint256)'];

const nftPointer = new ethers.Contract(pointerAddress, ERC721_ABI, signer);

// Check NFT ownership
const owner = await nftPointer.ownerOf(tokenId);
const balance = await nftPointer.balanceOf(userAddress);
```

## Troubleshooting

### Common Issues and Solutions

#### Pointer Creation Failures

```typescript copy
// Handle common pointer creation errors
async function createPointerWithErrorHandling(type, asset) {
  try {
    let tx;
    switch (type) {
      case 'native':
        tx = await pointer.addNativePointer(asset);
        break;
      case 'cw20':
        tx = await pointer.addCW20Pointer(asset);
        break;
      case 'cw721':
        tx = await pointer.addCW721Pointer(asset);
        break;
    }

    return await tx.wait();
  } catch (error) {
    if (error.message.includes('pointer already exists')) {
      console.log('Pointer already exists, retrieving existing address...');
      // Query existing pointer address
    } else if (error.message.includes('invalid token denom')) {
      console.error('Invalid token denomination:', asset);
    } else if (error.message.includes('contract does not exist')) {
      console.error('Contract not found:', asset);
    }
    throw error;
  }
}
```

#### Gas Estimation Issues

```typescript copy
// Proper gas estimation for different pointer types
async function estimatePointerGas(type, asset) {
  try {
    let gasEstimate;
    switch (type) {
      case 'native':
        gasEstimate = await pointer.addNativePointer.estimateGas(asset);
        break;
      case 'cw20':
        gasEstimate = await pointer.addCW20Pointer.estimateGas(asset);
        break;
      case 'cw721':
        gasEstimate = await pointer.addCW721Pointer.estimateGas(asset);
        gasEstimate = (gasEstimate * 15n) / 10n; // Add extra buffer for NFTs
        break;
    }

    return gasEstimate;
  } catch (error) {
    console.error('Gas estimation failed:', error);
    // Return default gas limits based on type
    switch (type) {
      case 'native':
        return 200000n;
      case 'cw20':
        return 250000n;
      case 'cw721':
        return 400000n;
      default:
        return 300000n;
    }
  }
}
```

### Error Code Reference

<div className="overflow-x-auto max-w-full">
  <table className="w-full divide-y divide-neutral-200 dark:divide-neutral-800">
    <thead>
      <tr>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Error</th>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Cause</th>
        <th className="px-4 py-3 text-left text-sm font-medium text-neutral-900 dark:text-neutral-100">Solution</th>
      </tr>
    </thead>
    <tbody className="divide-y divide-neutral-200 dark:divide-neutral-800">
      <tr>
        <td className="px-4 py-3 text-sm text-red-600 dark:text-red-400 whitespace-nowrap font-medium">
          <code>pointer already exists</code>
        </td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Pointer for this asset was already created</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Query existing pointer address instead</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-red-600 dark:text-red-400 whitespace-nowrap font-medium">
          <code>invalid token denom</code>
        </td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Invalid or non-existent native token denomination</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Verify token denomination exists on chain</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-red-600 dark:text-red-400 whitespace-nowrap font-medium">
          <code>contract does not exist</code>
        </td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">CosmWasm contract not found at address</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Verify contract address and ensure it's deployed</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-red-600 dark:text-red-400 whitespace-nowrap font-medium">
          <code>not a CW20 contract</code>
        </td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Contract exists but doesn't implement CW20 standard</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Use correct contract address for CW20 token</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-red-600 dark:text-red-400 whitespace-nowrap font-medium">
          <code>not a CW721 contract</code>
        </td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Contract exists but doesn't implement CW721 standard</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Use correct contract address for CW721 NFT</td>
      </tr>
      <tr>
        <td className="px-4 py-3 text-sm text-red-600 dark:text-red-400 whitespace-nowrap font-medium">
          <code>insufficient gas</code>
        </td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Gas limit too low for pointer creation</td>
        <td className="px-4 py-3 text-sm text-neutral-600 dark:text-neutral-400">Increase gas limit, especially for CW721</td>
      </tr>
    </tbody>
  </table>
</div>

## Important Notes

<Callout type="info">Remember: Pointer creation is a one-time operation per asset. Once created, the pointer address remains constant and can be used by any application.</Callout>

### Pointer Lifecycle

1. **Creation:** Pointer is created via precompile function
2. **Registration:** Pointer address is returned and can be stored
3. **Usage:** EVM applications can interact with the pointer using standard interfaces
4. **Persistence:** Pointers remain active as long as the underlying asset exists

### Best Practices

- **Validation First:** Always verify asset existence before creating pointers
- **Store Addresses:** Keep track of created pointer addresses for reuse
- **Error Handling:** Implement robust error handling for all pointer operations
- **Gas Management:** Use appropriate gas limits based on pointer type
- **Batch Operations:** Use batch functions for creating multiple pointers efficiently

### Asset Requirements

**Native Tokens:**

- Must be valid denominations registered on the Cosmos SDK bank module
- Common examples: `usei`, `uatom`, `uosmo`

**CW20 Contracts:**

- Must be deployed CosmWasm contracts implementing CW20 standard
- Address format: `sei1...` (bech32 encoded)

**CW721 Contracts:**

- Must be deployed CosmWasm contracts implementing CW721 standard
- Address format: `sei1...` (bech32 encoded)

### Integration Benefits

- **EVM Compatibility:** Use existing EVM tools with Cosmos assets
- **Unified Development:** Single interface for multiple asset types
- **Cross-Ecosystem:** Bridge between Cosmos and Ethereum ecosystems
- **Standards Compliance:** Automatic compliance with ERC-20/ERC-721 standards

<Callout type="info">View the Pointer precompile source code and the contract ABI [here](https://github.com/sei-protocol/sei-chain/tree/main/precompiles/pointer).</Callout>
